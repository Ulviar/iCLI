# Analysis Log — ICLI-023 — 2025-11-04

- **Author:** Assistant
- **Lifecycle stage:** Analysis
- **Context:** Establish scope and constraints for delivering listen-only streaming helpers.

## Knowledge consulted
- [AGENTS.md](/AGENTS.md) — Reconfirmed mandatory workflow items (Gradle via MCP, `.commit-message`, pre-response
  checks) and doc/test expectations that affect deliverables.
- [context/context-overview.md](../context-overview.md) — Walked through the checklist to ensure no governance document
  is skipped before implementation.
- [context/guidelines/coding/standards.md](../guidelines/coding/standards.md) &
  [context/guidelines/icli/assistant-notes.md](../guidelines/icli/assistant-notes.md) — Clarified nullability, record
  usage, and TDD requirements that will drive helper/class design and test ordering.
- [context/guidelines/general/markdown-formatting.md](../guidelines/general/markdown-formatting.md) — Determines
  formatting rules for README/roadmap updates the task requires.
- [context/roadmap/execution-architecture-brief.md](../roadmap/execution-architecture-brief.md) — Identified explicit
  expectation that `InteractiveSessionClient` supplies `Flow.Publisher<ByteBuffer>` and Kotlin `Flow<ByteString>`
  adapters for listen-only scenarios.
- [context/roadmap/project-roadmap.md](../roadmap/project-roadmap.md) &
  [context/roadmap/execution-use-case-catalogue.md](../roadmap/execution-use-case-catalogue.md) — Confirmed backlog
  intent: listen-only helpers must satisfy catalogue scenarios and be documented in consumer-facing guides.
- [context/knowledge-base/operations/Java Terminal & Process
  Integration.md](../knowledge-base/operations/Java%20Terminal%20%26%20Process%20Integration.md) — Reinforced PTY vs
  pipe handling considerations that influence streaming design (e.g., draining both streams concurrently).
- [context/research/icli-execution-engine-benchmarks.md](../research/icli-execution-engine-benchmarks.md) &
  [context/research/experiments/kotlin-solution-audit.md](../research/experiments/kotlin-solution-audit.md) — Provided
  reference patterns for streaming/log-follow APIs and highlighted pitfalls (busy-loop reads, lack of PTY) to avoid when
  designing new helpers.
- [README.md](/README.md) & [context/tasks/backlog.md](../tasks/backlog.md) — Captured consumer-facing scenario table
  and backlog Definition of Done aligns with delivering a dedicated listen-only runner.
- [context/testing/strategy.md](../testing/strategy.md) — Guides Kotlin/JUnit coverage expectations for new helpers,
  ensuring streaming tests capture success/failure/timeout paths.

## Repository inspection
- `src/main/java/com/github/ulviar/icli/client/*` — Reviewed existing runners (`CommandService`,
  `InteractiveSessionRunner`, `LineSessionRunner`) and clients to determine extension points for a listen-only facade.
- `src/main/java/com/github/ulviar/icli/client/internal/runner/*` — Inspected factories/launchers to understand how new
  runners should integrate without duplicating command-call construction.
- `src/test/kotlin` — Surveyed current test layout to plan placement for listen-only helper tests and confirm
  Kotlin/JUnit usage.

## Gaps & questions
- Need to define the exact API surface (method names, types) for listen-only helpers and how they expose stdout/stderr
  (single combined stream vs two publishers).
- Clarify whether pooled variants must ship alongside standard helpers in this task or if they fall under future backlog
  items.
- Determine backpressure semantics for the `Flow.Publisher` implementation to ensure it can keep up with high-velocity
  logs.

## Decision / readiness
- Ready to draft a concrete design and begin TDD once API surface/backpressure decisions are resolved during planning.

## Next steps
- Prototype API sketch (Java) for the listen-only runner/client and decide on publisher contracts.
- Outline test scenarios and fixtures.
- Update dossier Planning/Execution sections once design decisions are finalised.
