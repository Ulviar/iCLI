# Analysis Log — ICLI-025 — 2025-11-05

- **Author:** Assistant
- **Lifecycle stage:** Analysis
- **Context:** Establish requirements and existing capabilities before implementing pooled conversation affinity and
  health signalling.

## Knowledge consulted
- [execution-use-case-catalogue.md](/context/roadmap/execution-use-case-catalogue.md) — Confirms the stateful
  conversation scenario requires affinity keys plus manual reset/retirement hooks so callers can keep conversational
  context without hoarding leases.
- [process-pool-architecture.md](/context/roadmap/process-pool-architecture.md) — Describes current pool internals (idle
  queue handling, retirement policies, diagnostics) that any affinity-aware acquisition must respect.
- [execution-architecture-brief.md](/context/roadmap/execution-architecture-brief.md) — Clarifies that Essential APIs
  should expose `ServiceConversation` handles with listener instrumentation, while affinity helpers arrive through
  ICLI-025 without inventing new facades.
- [context/tasks/archive/ICLI-016/README.md](../../ICLI-016/README.md) — Documents the existing
  `ProcessPoolClient`, `ServiceProcessor`, and `ServiceConversation` contracts plus listener expectations that this task
  extends.

## Repository inspection
- `src/main/java/com/github/ulviar/icli/client/pooled/ProcessPoolClient.java` — Only exposes `openConversation()`
  without affinity metadata and always pipes acquisitions through `pool.acquire()`.
- `src/main/java/com/github/ulviar/icli/client/pooled/ServiceConversation.java` — Supports `reset()`/`retire()` but
  lacks reason codes or health callbacks beyond a generic `conversationReset` notification.
- `src/main/java/com/github/ulviar/icli/engine/pool/api/ProcessPool.java` and `internal/state/*` — Acquisition path
  cannot target a specific worker; idle selection is FIFO with no notion of affinity, so new selection logic (or
  caching) is required.
- `src/test/kotlin/com/github/ulviar/icli/client/pooled/ServiceConversationTest.kt` — Current coverage asserts listener
  ordering and reset behaviour but has no scenarios for affinity caching or diagnostic payloads, signalling where TDD
  needs to start.

## Gaps & questions
- Need a concrete design for expressing affinity keys (type, lifetime, eviction) without starving fair scheduling.
- Decide how diagnostics should surface retirement causes (new listener method vs enriched existing callbacks).
- Clarify whether affinity should be scoped to pooled runners only or also exposed via `ProcessPoolClient` for advanced
  callers.

## Decision / readiness
- Execution can begin once the affinity key representation and listener extensions are finalised; no additional research
  blockers identified.

## Next steps
- Design API additions (`ConversationAffinity`, listener callbacks, acquisition hooks) and document them in the dossier.
- Implement TDD plan: add failing tests covering affinity cache hits/misses and retirement signalling, then update
  pool/client implementations.
